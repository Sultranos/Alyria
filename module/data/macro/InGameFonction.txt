if (effet.conditionMonoCible(actor)) {
  // Appliquer le bonus si il n'y a personne dans un rayon de 10m
}

<!-- √Ä placer dans le formulaire de la fiche d‚Äôacteur -->
<div class="alyria-sorts-selection">
  <h3>Sorts √† choisir ({{system.nbSortsAChoisir}})</h3>
  <ul>
    {{#each system.sortsDisponibles as |sort|}}
      <li>
        <label>
          <input type="checkbox" name="sortsChoisis" value="{{sort.id}}" 
            {{#if (includes ../system.sortsChoisis sort.id)}}checked{{/if}} />
          {{sort.nom}}
        </label>
      </li>
    {{/each}}
  </ul>
<div>

// ================================
// MACRO DE CHECK-UP DES TALENTS (CORRIG√âE) - STRUCTURE DETECT√âE
// ================================

(async function() {
    console.log("üîç === D√âBUT DU CHECK-UP DES TALENTS ===");
    
    let rapport = {
        talents: {
            generaux: { total: 0, fonctionnels: 0, defaillants: [] },
            voies: { total: 0, fonctionnels: 0, defaillants: [] },
            arcanes: { total: 0, fonctionnels: 0, defaillants: [] },
            historiques: { total: 0, fonctionnels: 0, defaillants: [] }
        },
        fonctions: {
            disponibles: [],
            manquantes: []
        },
        erreurs: []
    };

    // ================================
    // 1. V√âRIFICATION DES MODULES DE TALENTS
    // ================================
    
    console.log("üìö V√©rification des modules de talents...");
    
    let talentStatistique, talentCombat, talentUtilitaire, talentCreation;
    let AlyriaVoies, AlyriaArcane, TalentFonctions;
    
    try {
        // Import des talents g√©n√©raux
        const talentsModule = await import('/systems/alyria/module/data/talents.js');
        talentStatistique = talentsModule.talentStatistique;
        talentCombat = talentsModule.talentCombat;
        talentUtilitaire = talentsModule.talentUtilitaire;
        talentCreation = talentsModule.talentCreation;
        
        // Import des voies et arcanes
        AlyriaVoies = (await import('/systems/alyria/module/data/AlyriaVoies.js')).AlyriaVoies;
        AlyriaArcane = (await import('/systems/alyria/module/data/AlyriaArcanes.js')).AlyriaArcane;
        
        // Import des fonctions de talents
        TalentFonctions = (await import('/systems/alyria/module/data/talentFonctions.js')).TalentFonctions;
        
        console.log("‚úÖ Modules import√©s avec succ√®s");
        
        // Debug: Afficher la structure des voies et arcanes
        console.log("üîç Debug AlyriaVoies:", AlyriaVoies);
        console.log("üîç Debug AlyriaArcane:", AlyriaArcane);
        
    } catch (error) {
        console.error("‚ùå Erreur lors de l'import des modules:", error);
        rapport.erreurs.push(`Erreur d'import: ${error.message}`);
    }

    // ================================
    // 2. V√âRIFICATION DES TALENTS G√âN√âRAUX
    // ================================
    
    console.log("üéØ V√©rification des talents g√©n√©raux...");
    
    // Talents Statistiques
    if (talentStatistique) {
        for (const [key, talent] of Object.entries(talentStatistique)) {
            rapport.talents.generaux.total++;
            
            const check = verifierTalent(talent, key, 'statistique');
            if (check.fonctionnel) {
                rapport.talents.generaux.fonctionnels++;
            } else {
                rapport.talents.generaux.defaillants.push({
                    nom: talent.nom || key,
                    type: 'Statistique',
                    problemes: check.problemes
                });
            }
        }
    }
    
    // Talents Combat
    if (talentCombat) {
        for (const [key, talent] of Object.entries(talentCombat)) {
            rapport.talents.generaux.total++;
            
            const check = verifierTalent(talent, key, 'combat');
            if (check.fonctionnel) {
                rapport.talents.generaux.fonctionnels++;
            } else {
                rapport.talents.generaux.defaillants.push({
                    nom: talent.nom || key,
                    type: 'Combat',
                    problemes: check.problemes
                });
            }
        }
    }
    
    // Talents Utilitaires
    if (talentUtilitaire) {
        for (const [key, talent] of Object.entries(talentUtilitaire)) {
            rapport.talents.generaux.total++;
            
            const check = verifierTalent(talent, key, 'utilitaire');
            if (check.fonctionnel) {
                rapport.talents.generaux.fonctionnels++;
            } else {
                rapport.talents.generaux.defaillants.push({
                    nom: talent.nom || key,
                    type: 'Utilitaire',
                    problemes: check.problemes
                });
            }
        }
    }
    
    // Talents Historiques
    if (talentCreation?.talentHistorique?.talents) {
        for (const talent of talentCreation.talentHistorique.talents) {
            rapport.talents.historiques.total++;
            
            const check = verifierTalent(talent, talent.nom, 'historique');
            if (check.fonctionnel) {
                rapport.talents.historiques.fonctionnels++;
            } else {
                rapport.talents.historiques.defaillants.push({
                    nom: talent.nom,
                    type: 'Historique',
                    problemes: check.problemes
                });
            }
        }
    }

    // ================================
    // 3. V√âRIFICATION DES TALENTS DE VOIES (CORRIG√âE)
    // ================================
    
    console.log("‚öîÔ∏è V√©rification des talents de voies...");
    
    if (AlyriaVoies) {
        console.log(`üîç Nombre de voies trouv√©es: ${Object.keys(AlyriaVoies).length}`);
        
        for (const [voieKey, voie] of Object.entries(AlyriaVoies)) {
            console.log(`üîç Analyse de la voie: ${voieKey}`, voie);
            
            // Chercher dans talentVoie.talents (structure d√©tect√©e)
            if (voie.talentVoie && voie.talentVoie.talents && Array.isArray(voie.talentVoie.talents)) {
                const talents = voie.talentVoie.talents;
                console.log(`‚úÖ Structure talentVoie.talents trouv√©e pour ${voieKey}: ${talents.length} talents`);
                
                for (const talent of talents) {
                    if (talent && typeof talent === 'object') {
                        rapport.talents.voies.total++;
                        
                        const check = verifierTalent(talent, `${voieKey}`, 'voie');
                        if (check.fonctionnel) {
                            rapport.talents.voies.fonctionnels++;
                        } else {
                            rapport.talents.voies.defaillants.push({
                                nom: talent.nom || 'Talent sans nom',
                                type: `Voie ${voie.nom || voieKey}`,
                                problemes: check.problemes
                            });
                        }
                    }
                }
            }
            // Structure alternative avec niveaux
            else if (voie.talentVoie && typeof voie.talentVoie === 'object') {
                console.log(`üîç Recherche dans les niveaux de talentVoie pour ${voieKey}:`, voie.talentVoie);
                
                for (const [niveauKey, niveauData] of Object.entries(voie.talentVoie)) {
                    if (niveauData && Array.isArray(niveauData.talents)) {
                        console.log(`‚úÖ Talents trouv√©s dans ${voieKey}.talentVoie.${niveauKey}: ${niveauData.talents.length} talents`);
                        
                        for (const talent of niveauData.talents) {
                            if (talent && typeof talent === 'object') {
                                rapport.talents.voies.total++;
                                
                                const check = verifierTalent(talent, `${voieKey}.${niveauKey}`, 'voie');
                                if (check.fonctionnel) {
                                    rapport.talents.voies.fonctionnels++;
                                } else {
                                    rapport.talents.voies.defaillants.push({
                                        nom: talent.nom || 'Talent sans nom',
                                        type: `Voie ${voie.nom || voieKey} (${niveauKey})`,
                                        problemes: check.problemes
                                    });
                                }
                            }
                        }
                    }
                }
            }
            else {
                console.log(`‚ö†Ô∏è Aucune structure de talents trouv√©e pour la voie: ${voieKey}`);
            }
        }
    }

    // ================================
    // 4. V√âRIFICATION DES TALENTS D'ARCANES (CORRIG√âE)
    // ================================
    
    console.log("üîÆ V√©rification des talents d'arcanes...");
    
    if (AlyriaArcane) {
        console.log(`üîç Nombre d'arcanes trouv√©s: ${Object.keys(AlyriaArcane).length}`);
        
        for (const [arcaneKey, arcane] of Object.entries(AlyriaArcane)) {
            console.log(`üîç Analyse de l'arcane: ${arcaneKey}`, arcane);
            
            // Chercher dans talentArcane.talents (structure d√©tect√©e dans les logs)
            if (arcane.talentArcane && arcane.talentArcane.talents && Array.isArray(arcane.talentArcane.talents)) {
                const talents = arcane.talentArcane.talents;
                console.log(`‚úÖ Structure talentArcane.talents trouv√©e pour ${arcaneKey}: ${talents.length} talents`);
                
                for (const talent of talents) {
                    if (talent && typeof talent === 'object') {
                        rapport.talents.arcanes.total++;
                        
                        const check = verifierTalent(talent, `${arcaneKey}`, 'arcane');
                        if (check.fonctionnel) {
                            rapport.talents.arcanes.fonctionnels++;
                        } else {
                            rapport.talents.arcanes.defaillants.push({
                                nom: talent.nom || 'Talent sans nom',
                                type: `Arcane ${arcane.nom || arcaneKey}`,
                                problemes: check.problemes
                            });
                        }
                    }
                }
            }
            // Structure alternative avec niveaux
            else if (arcane.talentArcane && typeof arcane.talentArcane === 'object') {
                console.log(`üîç Recherche dans les niveaux de talentArcane pour ${arcaneKey}:`, arcane.talentArcane);
                
                for (const [niveauKey, niveauData] of Object.entries(arcane.talentArcane)) {
                    if (niveauData && Array.isArray(niveauData.talents)) {
                        console.log(`‚úÖ Talents trouv√©s dans ${arcaneKey}.talentArcane.${niveauKey}: ${niveauData.talents.length} talents`);
                        
                        for (const talent of niveauData.talents) {
                            if (talent && typeof talent === 'object') {
                                rapport.talents.arcanes.total++;
                                
                                const check = verifierTalent(talent, `${arcaneKey}.${niveauKey}`, 'arcane');
                                if (check.fonctionnel) {
                                    rapport.talents.arcanes.fonctionnels++;
                                } else {
                                    rapport.talents.arcanes.defaillants.push({
                                        nom: talent.nom || 'Talent sans nom',
                                        type: `Arcane ${arcane.nom || arcaneKey} (${niveauKey})`,
                                        problemes: check.problemes
                                    });
                                }
                            }
                        }
                    }
                }
            }
            else {
                console.log(`‚ö†Ô∏è Aucune structure de talents trouv√©e pour l'arcane: ${arcaneKey}`);
            }
        }
    }

    // ================================
    // 5. V√âRIFICATION DES FONCTIONS DE TALENTS
    // ================================
    
    console.log("üîß V√©rification des fonctions de talents...");
    
    const fonctionsAttendues = [
        'ajoutDirectCaracteristiques',
        'ajoutDirectCaracteristique',
        'repartitionCaracteristiquesMajeures',
        'repartitionCaracteristiquesMineures',
        'repartitionCaracteristiquesMineurs',
        'bonusDirectPlusConditionnel',
        'bonusIndirectCaracteristique',
        'bonusIndirectCaracteristiques',
        'jetAvecBonusSituationnel'
    ];
    
    if (TalentFonctions) {
        for (const fonction of fonctionsAttendues) {
            if (typeof TalentFonctions[fonction] === 'function') {
                rapport.fonctions.disponibles.push(fonction);
            } else {
                rapport.fonctions.manquantes.push(fonction);
            }
        }
    } else {
        rapport.fonctions.manquantes = [...fonctionsAttendues];
        rapport.erreurs.push("Module TalentFonctions non disponible");
    }

    // ================================
    // 6. G√âN√âRATION DU RAPPORT
    // ================================
    
    console.log("üìä G√©n√©ration du rapport...");
    console.log("üìä Rapport final:", rapport);
    
    const html = genererRapportHTML(rapport);
    
    // Affichage du dialogue
    new Dialog({
        title: "üîç Check-up des Talents - Diagnostic Complet",
        content: html,
        render: (dialogHtml) => {
            // Ajouter les √©v√©nements pour les boutons d'expansion
            dialogHtml.find('.expand-btn').on('click', function() {
                const target = $(this).data('target');
                const section = dialogHtml.find(`#${target}`);
                const icon = $(this).find('i');
                
                if (section.hasClass('collapsed')) {
                    section.removeClass('collapsed');
                    icon.removeClass('fa-chevron-right').addClass('fa-chevron-down');
                } else {
                    section.addClass('collapsed');
                    icon.removeClass('fa-chevron-down').addClass('fa-chevron-right');
                }
            });
            
            // Boutons de test
            dialogHtml.find('.test-fonction-btn').on('click', async function() {
                const fonction = $(this).data('fonction');
                await testerFonction(fonction);
            });
        },
        buttons: {
            export: {
                icon: '<i class="fas fa-download"></i>',
                label: "Exporter le rapport",
                callback: () => exporterRapport(rapport)
            },
            repair: {
                icon: '<i class="fas fa-wrench"></i>',
                label: "Tenter des r√©parations",
                callback: () => tentativeReparation(rapport)
            },
            close: {
                icon: '<i class="fas fa-times"></i>',
                label: "Fermer"
            }
        }
    }, {
        width: 800,
        height: 700,
        resizable: true
    }).render(true);

    console.log("‚úÖ === CHECK-UP DES TALENTS TERMIN√â ===");

    // ================================
    // FONCTIONS UTILITAIRES
    // ================================

    function verifierTalent(talent, key, type) {
        const problemes = [];
        let fonctionnel = true;

        // V√©rifications de base
        if (!talent.nom) {
            problemes.push("Nom manquant");
            fonctionnel = false;
        }

        if (!talent.description && !talent.effet && !talent.effets) {
            problemes.push("Description/effet manquant");
            fonctionnel = false;
        }

        // V√©rifications sp√©cifiques selon le type
        if (type === 'historique') {
            if (!talent.effect && !talent.effets) {
                problemes.push("Propri√©t√© 'effect' ou 'effets' manquante");
                fonctionnel = false;
            }
        }

        // V√©rifications des fonctions
        if (talent.fonction) {
            if (TalentFonctions && typeof TalentFonctions[talent.fonction] !== 'function') {
                problemes.push(`Fonction '${talent.fonction}' non trouv√©e dans TalentFonctions`);
                fonctionnel = false;
            }
            
            // V√©rification de la coh√©rence entre fonction et effets
            if (talent.fonction === 'ajoutDirectCaracteristique' && !talent.effets) {
                problemes.push("Fonction ajoutDirectCaracteristique mais pas d'effets d√©finis");
                fonctionnel = false;
            }
        }

        // V√©rifications des effets structur√©s
        if (talent.effets) {
            if (talent.effets.majeure && typeof talent.effets.majeure !== 'object') {
                problemes.push("Structure 'effets.majeure' invalide");
                fonctionnel = false;
            }
            
            if (talent.effets.mineure && typeof talent.effets.mineure !== 'object') {
                problemes.push("Structure 'effets.mineure' invalide");
                fonctionnel = false;
            }
        }

        return { fonctionnel, problemes };
    }

    function genererRapportHTML(rapport) {
        const totalTalents = rapport.talents.generaux.total + rapport.talents.voies.total + 
                           rapport.talents.arcanes.total + rapport.talents.historiques.total;
        const totalFonctionnels = rapport.talents.generaux.fonctionnels + rapport.talents.voies.fonctionnels + 
                                 rapport.talents.arcanes.fonctionnels + rapport.talents.historiques.fonctionnels;
        
        const tauxReussite = totalTalents > 0 ? Math.round((totalFonctionnels / totalTalents) * 100) : 0;
        
        return `
            <div class="talent-checkup-rapport">
                <style>
                    .talent-checkup-rapport { font-family: Arial, sans-serif; font-size: 14px; }
                    .summary { background: linear-gradient(135deg, #e3f2fd, #f3e5f5); padding: 15px; border-radius: 8px; margin-bottom: 20px; }
                    .stat-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0; }
                    .stat-card { background: white; padding: 10px; border-radius: 5px; text-align: center; border: 1px solid #ddd; }
                    .stat-number { font-size: 24px; font-weight: bold; margin-bottom: 5px; }
                    .stat-label { font-size: 12px; color: #666; }
                    .success { color: #4CAF50; }
                    .warning { color: #FF9800; }
                    .error { color: #f44336; }
                    .section { margin-bottom: 20px; border: 1px solid #ddd; border-radius: 5px; }
                    .section-header { background: #f5f5f5; padding: 10px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
                    .section-content { padding: 15px; }
                    .collapsed { display: none; }
                    .problem-list { max-height: 200px; overflow-y: auto; }
                    .problem-item { background: rgba(244, 67, 54, 0.1); padding: 8px; margin: 5px 0; border-radius: 3px; border-left: 3px solid #f44336; }
                    .function-item { background: rgba(76, 175, 80, 0.1); padding: 8px; margin: 5px 0; border-radius: 3px; border-left: 3px solid #4CAF50; }
                    .missing-function { background: rgba(244, 67, 54, 0.1); border-left-color: #f44336; }
                    .test-btn { background: #2196F3; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; margin-left: 10px; }
                    .progress-bar { background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden; margin: 10px 0; }
                    .progress-fill { height: 100%; transition: width 0.3s ease; }
                </style>
                
                <div class="summary">
                    <h2>üìä R√©sum√© du Diagnostic</h2>
                    <div class="progress-bar">
                        <div class="progress-fill ${tauxReussite >= 80 ? 'success' : tauxReussite >= 60 ? 'warning' : 'error'}" 
                             style="width: ${tauxReussite}%; background: ${tauxReussite >= 80 ? '#4CAF50' : tauxReussite >= 60 ? '#FF9800' : '#f44336'};">
                        </div>
                    </div>
                    <p><strong>Taux de r√©ussite global : ${tauxReussite}%</strong> (${totalFonctionnels}/${totalTalents} talents fonctionnels)</p>
                </div>

                <div class="stat-grid">
                    <div class="stat-card">
                        <div class="stat-number success">${rapport.talents.generaux.fonctionnels}</div>
                        <div class="stat-label">Talents G√©n√©raux OK</div>
                        <div class="stat-label">(${rapport.talents.generaux.total} total)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number ${rapport.talents.voies.fonctionnels === rapport.talents.voies.total ? 'success' : 'warning'}">${rapport.talents.voies.fonctionnels}</div>
                        <div class="stat-label">Talents Voies OK</div>
                        <div class="stat-label">(${rapport.talents.voies.total} total)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number ${rapport.talents.arcanes.fonctionnels === rapport.talents.arcanes.total ? 'success' : 'warning'}">${rapport.talents.arcanes.fonctionnels}</div>
                        <div class="stat-label">Talents Arcanes OK</div>
                        <div class="stat-label">(${rapport.talents.arcanes.total} total)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number ${rapport.talents.historiques.fonctionnels === rapport.talents.historiques.total ? 'success' : 'warning'}">${rapport.talents.historiques.fonctionnels}</div>
                        <div class="stat-label">Talents Historiques OK</div>
                        <div class="stat-label">(${rapport.talents.historiques.total} total)</div>
                    </div>
                </div>

                ${genererSectionProblemes('Talents G√©n√©raux', rapport.talents.generaux.defaillants)}
                ${genererSectionProblemes('Talents de Voies', rapport.talents.voies.defaillants)}
                ${genererSectionProblemes('Talents d\'Arcanes', rapport.talents.arcanes.defaillants)}
                ${genererSectionProblemes('Talents Historiques', rapport.talents.historiques.defaillants)}
                ${genererSectionFonctions(rapport.fonctions)}
                ${rapport.erreurs.length > 0 ? genererSectionErreurs(rapport.erreurs) : ''}
            </div>
        `;
    }

    function genererSectionProblemes(titre, problemes) {
        if (problemes.length === 0) {
            return `
                <div class="section">
                    <div class="section-header">
                        <span><strong>${titre}</strong> <span class="success">‚úÖ Aucun probl√®me d√©tect√©</span></span>
                    </div>
                </div>
            `;
        }

        const problemesHtml = problemes.map(p => `
            <div class="problem-item">
                <strong>${p.nom}</strong> (${p.type})<br>
                <small>${p.problemes.join(', ')}</small>
            </div>
        `).join('');

        return `
            <div class="section">
                <div class="section-header expand-btn" data-target="section-${titre.replace(/\s+/g, '-')}">
                    <span><strong>${titre}</strong> <span class="error">‚ö†Ô∏è ${problemes.length} probl√®me(s)</span></span>
                    <i class="fas fa-chevron-right"></i>
                </div>
                <div class="section-content collapsed" id="section-${titre.replace(/\s+/g, '-')}">
                    <div class="problem-list">${problemesHtml}</div>
                </div>
            </div>
        `;
    }

    function genererSectionFonctions(fonctions) {
        const functionsHtml = fonctions.disponibles.map(f => `
            <div class="function-item">
                ‚úÖ ${f} 
                <button class="test-btn test-fonction-btn" data-fonction="${f}">Tester</button>
            </div>
        `).join('');

        const missingHtml = fonctions.manquantes.map(f => `
            <div class="function-item missing-function">‚ùå ${f} (manquante)</div>
        `).join('');

        return `
            <div class="section">
                <div class="section-header expand-btn" data-target="section-fonctions">
                    <span><strong>Fonctions de Talents</strong> ${fonctions.manquantes.length === 0 ? '<span class="success">‚úÖ Toutes disponibles</span>' : `<span class="error">‚ö†Ô∏è ${fonctions.manquantes.length} manquante(s)</span>`}</span>
                    <i class="fas fa-chevron-right"></i>
                </div>
                <div class="section-content collapsed" id="section-fonctions">
                    <h4>Fonctions Disponibles (${fonctions.disponibles.length}):</h4>
                    ${functionsHtml}
                    ${fonctions.manquantes.length > 0 ? `<h4>Fonctions Manquantes (${fonctions.manquantes.length}):</h4>${missingHtml}` : ''}
                </div>
            </div>
        `;
    }

    function genererSectionErreurs(erreurs) {
        const erreursHtml = erreurs.map(e => `<div class="problem-item">${e}</div>`).join('');
        
        return `
            <div class="section">
                <div class="section-header expand-btn" data-target="section-erreurs">
                    <span><strong>Erreurs Syst√®me</strong> <span class="error">‚ùå ${erreurs.length} erreur(s)</span></span>
                    <i class="fas fa-chevron-right"></i>
                </div>
                <div class="section-content collapsed" id="section-erreurs">
                    ${erreursHtml}
                </div>
            </div>
        `;
    }

    async function testerFonction(nomFonction) {
        try {
            console.log(`üß™ Test de la fonction: ${nomFonction}`);
            
            if (TalentFonctions && TalentFonctions[nomFonction]) {
                ui.notifications.info(`‚úÖ Fonction ${nomFonction} est accessible et callable`);
                console.log(`‚úÖ Fonction ${nomFonction} test√©e avec succ√®s`);
            } else {
                ui.notifications.error(`‚ùå Fonction ${nomFonction} non trouv√©e`);
            }
            
        } catch (error) {
            console.error(`‚ùå Erreur lors du test de ${nomFonction}:`, error);
            ui.notifications.error(`‚ùå Erreur lors du test: ${error.message}`);
        }
    }

    function exporterRapport(rapport) {
        const json = JSON.stringify(rapport, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `alyria-talents-checkup-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        
        URL.revokeObjectURL(url);
        ui.notifications.info("üìÑ Rapport export√© avec succ√®s");
    }

    function tentativeReparation(rapport) {
        ui.notifications.info("üîß Fonctionnalit√© de r√©paration en d√©veloppement...");
    }

})();